package generator

import (
	"fmt"
	"io"
	"strings"
	"text/template"

	"github.com/ornew/pego/pkg/grammer"
)

var tmpl *template.Template

var tmplText = `
// Code generated by pego. DO NOT EDIT.

package {{ .Grammer.Package }}

import (
	"fmt"

	"github.com/ornew/pego/pkg/cst"
	"github.com/ornew/pego/pkg/parser"
)

/*
{{ .Grammer }}
*/

const (
	Code__unknown uint32 = 0
	Code__root uint32 = 1
	{{- range .Named }}
	Code_{{ .Name }} uint32 = {{ .Code }}
	{{- end }}
)

var CodeNames = map[uint32]string{
	Code__unknown: "<unknown>",
	Code__root: "<root>",
	{{- range .Named }}
	Code_{{ .Name }}: "{{ .Name }}",
	{{- end }}
}

func Demangle(code uint32) (string, bool) {
	name, ok := CodeNames[code]
	if !ok {
		return "", false
	}
	return name, true
}

func Parse(p *parser.Parser) (node *cst.Node, err error) {
	p.SetRuleCodeSize({{ .NamedSize }})
	for {
		top := p.Top()
		if top == nil {
			return p.Head(), nil
		}
		switch top.Code {
		case 1:
			p.Alias(2)
		{{- range .Named }}
		case {{ .Code }}:
			{{ .Text }}
		{{- end }}
		{{- range .Hidden }}
		case {{ .Code }}:
			{{ .Text }}
		{{- end }}
		{{- range .Unnamed }}
		case {{ .Code }}:
			{{ .Text }}
		{{- end }}
		default:
			return nil, fmt.Errorf("unknown code: %d", top.Code)
		}
	}
}
`

func init() {
	var err error
	tmpl, err = template.New("").Parse(tmplText)
	if err != nil {
		panic(err)
	}
}

type Code struct {
	Expr   *grammer.Expression
	Render func() string
	Name   string
	Text   string
	Code   uint32
}

type Generator struct {
	Grammer   *grammer.Grammer
	index     map[string]*Code
	Named     []*Code
	Hidden    []*Code
	Unnamed   []*Code
	NamedSize uint32
	last      uint32
}

func NewGenerator() *Generator {
	return &Generator{
		Named:     []*Code{},
		Hidden:    []*Code{},
		Unnamed:   []*Code{},
		NamedSize: 0,
		last:      2,
		index:     map[string]*Code{},
	}
}

func (g *Generator) AddGrammer(gr *grammer.Grammer) {
	g.Grammer = gr
	for _, rule := range gr.Rules {
		if strings.HasPrefix(rule.Name, "_") {
			g.addHiddenRule(rule)
			continue
		}
		g.addNamedRule(rule)
	}
}

func (g *Generator) addNamedRule(rule *grammer.Rule) {
	code := &Code{
		Name: rule.Name,
		Expr: rule.Expression,
	}
	g.Named = append(g.Named, code)
	g.index[code.Name] = code
	g.register(code)
}

func (g *Generator) addHiddenRule(rule *grammer.Rule) {
	code := &Code{
		Name: rule.Name,
		Expr: rule.Expression,
	}
	g.Hidden = append(g.Hidden, code)
	g.index[code.Name] = code
	g.register(code)
}

func (g *Generator) addSubRule(p *Code, i uint32, e *grammer.Expression) *Code {
	c := &Code{
		Name: fmt.Sprintf("%s_%d", p.Name, i),
		Expr: e,
	}
	g.Unnamed = append(g.Unnamed, c)
	g.index[c.Name] = c
	g.register(c)
	return c
}

func (g *Generator) register(c *Code) {
	e := c.Expr
	switch {
	case e.TerminalSymbol != nil:
		if len(e.TerminalSymbol.Text) == 1 {
			c.Render = func() string {
				return fmt.Sprintf(`p.TerminalChar(%q)`, rune(e.TerminalSymbol.Text[0]))
			}
		} else {
			c.Render = func() string {
				return fmt.Sprintf(`p.Terminal([]byte(%q))`, e.TerminalSymbol.Text)
			}
		}
	case e.TerminalSymbolRange != nil:
		c.Render = func() string {
			return fmt.Sprintf(`p.TerminalRange('%s', '%s')`, e.TerminalSymbolRange.Start, e.TerminalSymbolRange.End)
		}
	case e.NonTerminalSymbol != nil:
		c.Render = func() string {
			a, ok := g.index[e.NonTerminalSymbol.Name]
			if !ok {
				panic(fmt.Errorf("not found: %s", e.NonTerminalSymbol.Name))
			}
			return fmt.Sprintf(`// %s (from %s)`, e.NonTerminalSymbol.String(), c.Expr.String()) + "\n" +
				fmt.Sprintf(`p.Alias(%d)`, a.Code)
		}
	case e.Sequence != nil:
		a := g.addSubRule(c, 0, e.Sequence.A)
		b := g.addSubRule(c, 1, e.Sequence.B)
		c.Render = func() string {
			return fmt.Sprintf(`// %s`, e.Sequence.String()) + "\n" +
				fmt.Sprintf(`p.Sequence(%d, %d)`, a.Code, b.Code)
		}
	case e.Choice != nil:
		a := g.addSubRule(c, 0, e.Choice.A)
		b := g.addSubRule(c, 1, e.Choice.B)
		c.Render = func() string {
			return fmt.Sprintf(`// %s`, e.Choice.String()) + "\n" +
				fmt.Sprintf(`p.Choice(%d, %d)`, a.Code, b.Code)
		}
	case e.ZeroOrMore != nil:
		a := g.addSubRule(c, 0, e.ZeroOrMore.Expression)
		c.Render = func() string {
			return fmt.Sprintf(`// %s`, e.ZeroOrMore.String()) + "\n" +
				fmt.Sprintf(`p.ZeroOrMore(%d)`, a.Code)
		}
	case e.OneOrMore != nil:
		a := g.addSubRule(c, 0, e.OneOrMore.Expression)
		c.Render = func() string {
			return fmt.Sprintf(`// %s`, e.OneOrMore.String()) + "\n" +
				fmt.Sprintf(`p.OneOrMore(%d)`, a.Code)
		}
	case e.Optional != nil:
		a := g.addSubRule(c, 0, e.Optional.Expression)
		c.Render = func() string {
			return fmt.Sprintf(`// %s`, e.Optional.String()) + "\n" +
				fmt.Sprintf(`p.Optional(%d)`, a.Code)
		}
	case e.AndPredicate != nil:
		a := g.addSubRule(c, 0, e.AndPredicate.Expression)
		c.Render = func() string {
			return fmt.Sprintf(`// %s`, e.AndPredicate.String()) + "\n" +
				fmt.Sprintf(`p.AndPredicate(%d)`, a.Code)
		}
	case e.NotPredicate != nil:
		a := g.addSubRule(c, 0, e.NotPredicate.Expression)
		c.Render = func() string {
			return fmt.Sprintf(`// %s`, e.NotPredicate.String()) + "\n" +
				fmt.Sprintf(`p.NotPredicate(%d)`, a.Code)
		}
	case e.Group != nil:
		a := g.addSubRule(c, 0, e.Group.Expression)
		c.Render = func() string {
			return fmt.Sprintf(`// %s`, e.Group.String()) + "\n" +
				fmt.Sprintf(`p.Group(%d)`, a.Code)
		}
	case e.AnyChar != nil:
		c.Render = func() string {
			return `p.AnyChar()`
		}
	}
}

func (g *Generator) Generate(w io.Writer) error {
	for _, x := range g.Named {
		x.Code = g.last
		g.last++
	}
	g.NamedSize = g.last - 1
	for _, x := range g.Hidden {
		x.Code = g.last
		g.last++
	}
	for _, x := range g.Unnamed {
		x.Code = g.last
		g.last++
	}
	for _, x := range g.Named {
		x.Text = x.Render()
	}
	for _, x := range g.Hidden {
		x.Text = x.Render()
	}
	for _, x := range g.Unnamed {
		x.Text = x.Render()
	}
	return tmpl.Execute(w, g)
}

func Generate(w io.Writer, g *grammer.Grammer) error {
	gen := NewGenerator()
	gen.AddGrammer(g)
	return gen.Generate(w)
}
