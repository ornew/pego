package generator

import (
	"fmt"
	"io"
	"text/template"

	"github.com/ornew/pego/pkg/grammer"
)

var tmpl *template.Template

var tmplText = `
// Code generated by pego. DO NOT EDIT.

package {{ .Package }}

import (
	"fmt"

	"github.com/ornew/pego/pkg/cst"
	"github.com/ornew/pego/pkg/parser"
)

/*
{{ .Grammer }}
*/

var CodeNames = map[uint32]string{
	{{- range .CodeNames }}
	{{ .Code }}: "{{ .Name }}",
	{{- end }}
}

func Demangle(code uint32) (string, bool) {
	name, ok := CodeNames[code]
	if !ok {
		return "", false
	}
	return name, true
}

func Parse(p *parser.Parser) (node *cst.Node, err error) {
	p.SetRuleCodeSize({{ len .CodeNames }})
	for {
		top := p.Top()
		if top == nil {
			return p.Head(), nil
		}
		switch top.Code {
		{{- range .Codes }}
		case {{ .ID }}:
			{{- range .Expr }}
			{{ . }}
			{{- end -}}
		{{- end }}
		default:
			return nil, fmt.Errorf("unknown code: %d", top.Code)
		}
	}
}
`

func init() {
	var err error
	tmpl, err = template.New("").Parse(tmplText)
	if err != nil {
		panic(err)
	}
}

type CodeName struct {
	Code uint32
	Name string
}

type Code struct {
	ID   uint32
	Expr []string
}

func Generate(w io.Writer, g *grammer.Grammer) error {
	var last uint32
	var ruleCodes, codes []*Code
	var codenames []*CodeName
	index := map[*grammer.Expression]uint32{}
	ruleCodeMap := map[string]uint32{}
	ruleMap := map[string]*grammer.Expression{}
	for i, rule := range g.Rules {
		code := uint32(i + 1)
		ruleMap[rule.Name] = rule.Expression
		ruleCodeMap[rule.Name] = code
		codenames = append(codenames, &CodeName{
			Code: code,
			Name: rule.Name,
		})
	}
	last = uint32(len(codenames)) + 1
	var add func(parent, e *grammer.Expression) uint32
	add = func(parent, e *grammer.Expression) uint32 {
		id, ok := index[e]
		if ok {
			return id
		}
		c := &Code{
			ID: last,
		}
		last++
		index[e] = c.ID
		codes = append(codes, c)
		switch {
		case e.TerminalSymbol != nil:
			if len(e.TerminalSymbol.Text) == 1 {
				c.Expr = append(c.Expr, fmt.Sprintf(`p.TerminalChar('%s')`, e.TerminalSymbol.Text))
			} else {
				c.Expr = append(c.Expr, fmt.Sprintf(`p.Terminal("%s")`, e.TerminalSymbol.Text))
			}
		case e.TerminalSymbolRange != nil:
			c.Expr = append(c.Expr, fmt.Sprintf(`p.TerminalRange('%s', '%s')`, e.TerminalSymbolRange.Start, e.TerminalSymbolRange.End))
		case e.NonTerminalSymbol != nil:
			a, ok := ruleCodeMap[e.NonTerminalSymbol.Name]
			if !ok {
				panic(fmt.Errorf("not found: %s", e.NonTerminalSymbol.Name))
			}
			c.Expr = append(c.Expr,
				fmt.Sprintf(`// %s (from %s)`, e.NonTerminalSymbol.String(), parent.String()),
				fmt.Sprintf(`p.Alias(%d)`, a),
			)
		case e.Sequence != nil:
			a := add(e, e.Sequence.A)
			b := add(e, e.Sequence.B)
			c.Expr = append(c.Expr,
				fmt.Sprintf(`// %s`, e.Sequence.String()),
				fmt.Sprintf(`p.Sequence(%d, %d)`, a, b),
			)
		case e.Choice != nil:
			a := add(e, e.Choice.A)
			b := add(e, e.Choice.B)
			c.Expr = append(c.Expr,
				fmt.Sprintf(`// %s`, e.Choice.String()),
				fmt.Sprintf(`p.Choice(%d, %d)`, a, b),
			)
		case e.ZeroOrMore != nil:
			a := add(e, e.ZeroOrMore.Expression)
			c.Expr = append(c.Expr,
				fmt.Sprintf(`// %s`, e.ZeroOrMore.String()),
				fmt.Sprintf(`p.ZeroOrMore(%d)`, a),
			)
		case e.OneOrMore != nil:
			a := add(e, e.OneOrMore.Expression)
			c.Expr = append(c.Expr,
				fmt.Sprintf(`// %s`, e.OneOrMore.String()),
				fmt.Sprintf(`p.OneOrMore(%d)`, a),
			)
		case e.Optional != nil:
			a := add(e, e.Optional.Expression)
			c.Expr = append(c.Expr,
				fmt.Sprintf(`// %s`, e.Optional.String()),
				fmt.Sprintf(`p.Optional(%d)`, a),
			)
		case e.AndPredicate != nil:
			a := add(e, e.AndPredicate.Expression)
			c.Expr = append(c.Expr,
				fmt.Sprintf(`// %s`, e.AndPredicate.String()),
				fmt.Sprintf(`p.AndPredicate(%d)`, a),
			)
		case e.NotPredicate != nil:
			a := add(e, e.NotPredicate.Expression)
			c.Expr = append(c.Expr,
				fmt.Sprintf(`// %s`, e.NotPredicate.String()),
				fmt.Sprintf(`p.NotPredicate(%d)`, a),
			)
		case e.Group != nil:
			a := add(e, e.Group.Expression)
			c.Expr = append(c.Expr,
				fmt.Sprintf(`// %s`, e.Group.String()),
				fmt.Sprintf(`p.Group(%d)`, a),
			)
		}
		return c.ID
	}
	for _, rule := range g.Rules {
		c := &Code{
			ID: ruleCodeMap[rule.Name],
		}
		expr := add(rule.Expression, rule.Expression)
		c.Expr = append(c.Expr,
			fmt.Sprintf(`// %s <- %s`, rule.Name, rule.Expression.String()),
			fmt.Sprintf(`p.Alias(%d)`, expr),
		)
		ruleCodes = append(ruleCodes, c)
	}
	codes = append(ruleCodes, codes...)
	fmt.Printf("%s\n", g.String())
	tmpl.Execute(w, struct {
		Grammer   *grammer.Grammer
		Package   string
		Codes     []*Code
		CodeNames []*CodeName
	}{
		Grammer:   g,
		Package:   g.Package,
		Codes:     codes,
		CodeNames: codenames,
	})
	return nil
}
