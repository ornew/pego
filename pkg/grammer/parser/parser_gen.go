// Code generated by pego. DO NOT EDIT.

package parser

import (
	"fmt"

	"github.com/ornew/pego/pkg/cst"
	"github.com/ornew/pego/pkg/parser"
)

/*
package parser

file <- _spaceline? package_statement (_spaceline / rule_statement)+
package_statement <- "package" _space ident
rule_statement <- ident _space "<-" _space expr
expr <- term (_space term_binary_op _space term)*
term_binary_op <- "/"
term <- factor (factor_binary_op factor)*
factor_binary_op <- " "+
factor <- primary_prefix_unary_op? primary primary_postfix_unary_op?
primary_prefix_unary_op <- "&" / "!"
primary_postfix_unary_op <- "*" / "+" / "?"
primary <- any_char_op / group / constant
group <- "(" expr ")"
constant <- terminal_symbol_range / terminal_symbol / ident
terminal_symbol <- "\"" string "\""
terminal_symbol_range <- "[" charactor "-" charactor "]"
ident <- ("_" / [a-z])+
string <- ("\\" . / !("\"" / "\n") charactor)+
any_char_op <- "."
charactor <- .
_spaceline <- "\n"+
_space <- " "*
*/

const (
	Code__unknown                 uint32 = 0
	Code__root                    uint32 = 1
	Code_file                     uint32 = 2
	Code_package_statement        uint32 = 3
	Code_rule_statement           uint32 = 4
	Code_expr                     uint32 = 5
	Code_term_binary_op           uint32 = 6
	Code_term                     uint32 = 7
	Code_factor_binary_op         uint32 = 8
	Code_factor                   uint32 = 9
	Code_primary_prefix_unary_op  uint32 = 10
	Code_primary_postfix_unary_op uint32 = 11
	Code_primary                  uint32 = 12
	Code_group                    uint32 = 13
	Code_constant                 uint32 = 14
	Code_terminal_symbol          uint32 = 15
	Code_terminal_symbol_range    uint32 = 16
	Code_ident                    uint32 = 17
	Code_string                   uint32 = 18
	Code_any_char_op              uint32 = 19
	Code_charactor                uint32 = 20
)

var CodeNames = map[uint32]string{
	Code__unknown:                 "<unknown>",
	Code__root:                    "<root>",
	Code_file:                     "file",
	Code_package_statement:        "package_statement",
	Code_rule_statement:           "rule_statement",
	Code_expr:                     "expr",
	Code_term_binary_op:           "term_binary_op",
	Code_term:                     "term",
	Code_factor_binary_op:         "factor_binary_op",
	Code_factor:                   "factor",
	Code_primary_prefix_unary_op:  "primary_prefix_unary_op",
	Code_primary_postfix_unary_op: "primary_postfix_unary_op",
	Code_primary:                  "primary",
	Code_group:                    "group",
	Code_constant:                 "constant",
	Code_terminal_symbol:          "terminal_symbol",
	Code_terminal_symbol_range:    "terminal_symbol_range",
	Code_ident:                    "ident",
	Code_string:                   "string",
	Code_any_char_op:              "any_char_op",
	Code_charactor:                "charactor",
}

func Demangle(code uint32) (string, bool) {
	name, ok := CodeNames[code]
	if !ok {
		return "", false
	}
	return name, true
}

func Parse(p *parser.Parser) (node *cst.Node, err error) {
	p.SetRuleCodeSize(20)
	for {
		top := p.Top()
		if top == nil {
			return p.Head(), nil
		}
		switch top.Code {
		case 1:
			p.Alias(2)
		case 2:
			// _spaceline? package_statement (_spaceline / rule_statement)+
			p.Sequence(23, 25)
		case 3:
			// "package" _space ident
			p.Sequence(31, 32)
		case 4:
			// ident _space "<-" _space expr
			p.Sequence(35, 36)
		case 5:
			// term (_space term_binary_op _space term)*
			p.Sequence(43, 44)
		case 6:
			p.TerminalChar('/')
		case 7:
			// factor (factor_binary_op factor)*
			p.Sequence(52, 53)
		case 8:
			// " "+
			p.OneOrMore(57)
		case 9:
			// primary_prefix_unary_op? primary primary_postfix_unary_op?
			p.Sequence(58, 60)
		case 10:
			// "&" / "!"
			p.Choice(64, 65)
		case 11:
			// "*" / "+" / "?"
			p.Choice(66, 67)
		case 12:
			// any_char_op / group / constant
			p.Choice(70, 71)
		case 13:
			// "(" expr ")"
			p.Sequence(74, 75)
		case 14:
			// terminal_symbol_range / terminal_symbol / ident
			p.Choice(78, 79)
		case 15:
			// "\"" string "\""
			p.Sequence(82, 83)
		case 16:
			// "[" charactor "-" charactor "]"
			p.Sequence(86, 87)
		case 17:
			// ("_" / [a-z])+
			p.OneOrMore(94)
		case 18:
			// ("\\" . / !("\"" / "\n") charactor)+
			p.OneOrMore(97)
		case 19:
			p.TerminalChar('.')
		case 20:
			p.AnyChar()
		case 21:
			// "\n"+
			p.OneOrMore(107)
		case 22:
			// " "*
			p.ZeroOrMore(108)
		case 23:
			// _spaceline?
			p.Optional(24)
		case 24:
			// _spaceline (from _spaceline)
			p.Alias(21)
		case 25:
			// package_statement (_spaceline / rule_statement)+
			p.Sequence(26, 27)
		case 26:
			// package_statement (from package_statement)
			p.Alias(3)
		case 27:
			// (_spaceline / rule_statement)+
			p.OneOrMore(28)
		case 28:
			// _spaceline / rule_statement
			p.Choice(29, 30)
		case 29:
			// _spaceline (from _spaceline)
			p.Alias(21)
		case 30:
			// rule_statement (from rule_statement)
			p.Alias(4)
		case 31:
			p.Terminal([]byte("package"))
		case 32:
			// _space ident
			p.Sequence(33, 34)
		case 33:
			// _space (from _space)
			p.Alias(22)
		case 34:
			// ident (from ident)
			p.Alias(17)
		case 35:
			// ident (from ident)
			p.Alias(17)
		case 36:
			// _space "<-" _space expr
			p.Sequence(37, 38)
		case 37:
			// _space (from _space)
			p.Alias(22)
		case 38:
			// "<-" _space expr
			p.Sequence(39, 40)
		case 39:
			p.Terminal([]byte("<-"))
		case 40:
			// _space expr
			p.Sequence(41, 42)
		case 41:
			// _space (from _space)
			p.Alias(22)
		case 42:
			// expr (from expr)
			p.Alias(5)
		case 43:
			// term (from term)
			p.Alias(7)
		case 44:
			// (_space term_binary_op _space term)*
			p.ZeroOrMore(45)
		case 45:
			// _space term_binary_op _space term
			p.Sequence(46, 47)
		case 46:
			// _space (from _space)
			p.Alias(22)
		case 47:
			// term_binary_op _space term
			p.Sequence(48, 49)
		case 48:
			// term_binary_op (from term_binary_op)
			p.Alias(6)
		case 49:
			// _space term
			p.Sequence(50, 51)
		case 50:
			// _space (from _space)
			p.Alias(22)
		case 51:
			// term (from term)
			p.Alias(7)
		case 52:
			// factor (from factor)
			p.Alias(9)
		case 53:
			// (factor_binary_op factor)*
			p.ZeroOrMore(54)
		case 54:
			// factor_binary_op factor
			p.Sequence(55, 56)
		case 55:
			// factor_binary_op (from factor_binary_op)
			p.Alias(8)
		case 56:
			// factor (from factor)
			p.Alias(9)
		case 57:
			p.TerminalChar(' ')
		case 58:
			// primary_prefix_unary_op?
			p.Optional(59)
		case 59:
			// primary_prefix_unary_op (from primary_prefix_unary_op)
			p.Alias(10)
		case 60:
			// primary primary_postfix_unary_op?
			p.Sequence(61, 62)
		case 61:
			// primary (from primary)
			p.Alias(12)
		case 62:
			// primary_postfix_unary_op?
			p.Optional(63)
		case 63:
			// primary_postfix_unary_op (from primary_postfix_unary_op)
			p.Alias(11)
		case 64:
			p.TerminalChar('&')
		case 65:
			p.TerminalChar('!')
		case 66:
			p.TerminalChar('*')
		case 67:
			// "+" / "?"
			p.Choice(68, 69)
		case 68:
			p.TerminalChar('+')
		case 69:
			p.TerminalChar('?')
		case 70:
			// any_char_op (from any_char_op)
			p.Alias(19)
		case 71:
			// group / constant
			p.Choice(72, 73)
		case 72:
			// group (from group)
			p.Alias(13)
		case 73:
			// constant (from constant)
			p.Alias(14)
		case 74:
			p.TerminalChar('(')
		case 75:
			// expr ")"
			p.Sequence(76, 77)
		case 76:
			// expr (from expr)
			p.Alias(5)
		case 77:
			p.TerminalChar(')')
		case 78:
			// terminal_symbol_range (from terminal_symbol_range)
			p.Alias(16)
		case 79:
			// terminal_symbol / ident
			p.Choice(80, 81)
		case 80:
			// terminal_symbol (from terminal_symbol)
			p.Alias(15)
		case 81:
			// ident (from ident)
			p.Alias(17)
		case 82:
			p.TerminalChar('"')
		case 83:
			// string "\""
			p.Sequence(84, 85)
		case 84:
			// string (from string)
			p.Alias(18)
		case 85:
			p.TerminalChar('"')
		case 86:
			p.TerminalChar('[')
		case 87:
			// charactor "-" charactor "]"
			p.Sequence(88, 89)
		case 88:
			// charactor (from charactor)
			p.Alias(20)
		case 89:
			// "-" charactor "]"
			p.Sequence(90, 91)
		case 90:
			p.TerminalChar('-')
		case 91:
			// charactor "]"
			p.Sequence(92, 93)
		case 92:
			// charactor (from charactor)
			p.Alias(20)
		case 93:
			p.TerminalChar(']')
		case 94:
			// "_" / [a-z]
			p.Choice(95, 96)
		case 95:
			p.TerminalChar('_')
		case 96:
			p.TerminalRange('a', 'z')
		case 97:
			// "\\" . / !("\"" / "\n") charactor
			p.Choice(98, 101)
		case 98:
			// "\\" .
			p.Sequence(99, 100)
		case 99:
			p.TerminalChar('\\')
		case 100:
			p.AnyChar()
		case 101:
			// !("\"" / "\n") charactor
			p.Sequence(102, 106)
		case 102:
			// !("\"" / "\n")
			p.NotPredicate(103)
		case 103:
			// "\"" / "\n"
			p.Choice(104, 105)
		case 104:
			p.TerminalChar('"')
		case 105:
			p.TerminalChar('\n')
		case 106:
			// charactor (from charactor)
			p.Alias(20)
		case 107:
			p.TerminalChar('\n')
		case 108:
			p.TerminalChar(' ')
		default:
			return nil, fmt.Errorf("unknown code: %d", top.Code)
		}
	}
}
