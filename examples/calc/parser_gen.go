// Code generated by pego. DO NOT EDIT.

package calc

import (
	"fmt"

	"github.com/ornew/pego/pkg/cst"
	"github.com/ornew/pego/pkg/parser"
)

/*
package calc

expr <- term (term_binary_op term)*
term <- factor (factor_binary_op factor)*
term_binary_op <- "+" / "-"
factor_binary_op <- "*" / "/"
factor <- group / number
group <- "(" expr ")"
number <- [0-9]+
*/

const (
	Code__unknown         uint32 = 0
	Code__root            uint32 = 1
	Code_expr             uint32 = 2
	Code_term             uint32 = 3
	Code_term_binary_op   uint32 = 4
	Code_factor_binary_op uint32 = 5
	Code_factor           uint32 = 6
	Code_group            uint32 = 7
	Code_number           uint32 = 8
)

var CodeNames = map[uint32]string{
	Code__unknown:         "<unknown>",
	Code__root:            "<root>",
	Code_expr:             "expr",
	Code_term:             "term",
	Code_term_binary_op:   "term_binary_op",
	Code_factor_binary_op: "factor_binary_op",
	Code_factor:           "factor",
	Code_group:            "group",
	Code_number:           "number",
}

func Demangle(code uint32) (string, bool) {
	name, ok := CodeNames[code]
	if !ok {
		return "", false
	}
	return name, true
}

func Parse(p *parser.Parser) (node *cst.Node, err error) {
	p.SetRuleCodeSize(8)
	for {
		top := p.Top()
		if top == nil {
			return p.Head(), nil
		}
		switch top.Code {
		case 1:
			p.Alias(2)
		case 2:
			// term (term_binary_op term)*
			p.Sequence(9, 10)
		case 3:
			// factor (factor_binary_op factor)*
			p.Sequence(14, 15)
		case 4:
			// "+" / "-"
			p.Choice(19, 20)
		case 5:
			// "*" / "/"
			p.Choice(21, 22)
		case 6:
			// group / number
			p.Choice(23, 24)
		case 7:
			// "(" expr ")"
			p.Sequence(25, 26)
		case 8:
			// [0-9]+
			p.OneOrMore(29)
		case 9:
			// term (from term)
			p.Alias(3)
		case 10:
			// (term_binary_op term)*
			p.ZeroOrMore(11)
		case 11:
			// term_binary_op term
			p.Sequence(12, 13)
		case 12:
			// term_binary_op (from term_binary_op)
			p.Alias(4)
		case 13:
			// term (from term)
			p.Alias(3)
		case 14:
			// factor (from factor)
			p.Alias(6)
		case 15:
			// (factor_binary_op factor)*
			p.ZeroOrMore(16)
		case 16:
			// factor_binary_op factor
			p.Sequence(17, 18)
		case 17:
			// factor_binary_op (from factor_binary_op)
			p.Alias(5)
		case 18:
			// factor (from factor)
			p.Alias(6)
		case 19:
			p.TerminalChar('+')
		case 20:
			p.TerminalChar('-')
		case 21:
			p.TerminalChar('*')
		case 22:
			p.TerminalChar('/')
		case 23:
			// group (from group)
			p.Alias(7)
		case 24:
			// number (from number)
			p.Alias(8)
		case 25:
			p.TerminalChar('(')
		case 26:
			// expr ")"
			p.Sequence(27, 28)
		case 27:
			// expr (from expr)
			p.Alias(2)
		case 28:
			p.TerminalChar(')')
		case 29:
			p.TerminalRange('0', '9')
		default:
			return nil, fmt.Errorf("unknown code: %d", top.Code)
		}
	}
}
