// Code generated by pego. DO NOT EDIT.

package calc

import (
	"fmt"

	"github.com/ornew/pego/pkg/cst"
	"github.com/ornew/pego/pkg/parser"
)

/*
expr <- term
term <- factor (term_binary_op factor)*
factor <- value (factor_binary_op value)*
term_binary_op <- "+" / "-"
factor_binary_op <- "*" / "/"
value <- number / group
group <- "(" term ")"
number <- [0-9]+
*/

var CodeNames = map[uint32]string{
	1: "expr",
	2: "term",
	3: "factor",
	4: "term_binary_op",
	5: "factor_binary_op",
	6: "value",
	7: "group",
	8: "number",
}

func Demangle(code uint32) (string, bool) {
	name, ok := CodeNames[code]
	if !ok {
		return "", false
	}
	return name, true
}

func Parse(p *parser.Parser) (node *cst.Node, err error) {
	p.SetRuleCodeSize(8)
	for {
		top := p.Top()
		if top == nil {
			return p.Head(), nil
		}
		switch top.Code {
		case 1:
			// expr <- term
			p.Alias(9)
		case 2:
			// term <- factor (term_binary_op factor)*
			p.Alias(10)
		case 3:
			// factor <- value (factor_binary_op value)*
			p.Alias(16)
		case 4:
			// term_binary_op <- "+" / "-"
			p.Alias(22)
		case 5:
			// factor_binary_op <- "*" / "/"
			p.Alias(25)
		case 6:
			// value <- number / group
			p.Alias(28)
		case 7:
			// group <- "(" term ")"
			p.Alias(31)
		case 8:
			// number <- [0-9]+
			p.Alias(36)
		case 9:
			// term (from term)
			p.Alias(2)
		case 10:
			// factor (term_binary_op factor)*
			p.Sequence(11, 12)
		case 11:
			// factor (from factor (term_binary_op factor)*)
			p.Alias(3)
		case 12:
			// (term_binary_op factor)*
			p.ZeroOrMore(13)
		case 13:
			// term_binary_op factor
			p.Sequence(14, 15)
		case 14:
			// term_binary_op (from term_binary_op factor)
			p.Alias(4)
		case 15:
			// factor (from term_binary_op factor)
			p.Alias(3)
		case 16:
			// value (factor_binary_op value)*
			p.Sequence(17, 18)
		case 17:
			// value (from value (factor_binary_op value)*)
			p.Alias(6)
		case 18:
			// (factor_binary_op value)*
			p.ZeroOrMore(19)
		case 19:
			// factor_binary_op value
			p.Sequence(20, 21)
		case 20:
			// factor_binary_op (from factor_binary_op value)
			p.Alias(5)
		case 21:
			// value (from factor_binary_op value)
			p.Alias(6)
		case 22:
			// "+" / "-"
			p.Choice(23, 24)
		case 23:
			p.TerminalChar('+')
		case 24:
			p.TerminalChar('-')
		case 25:
			// "*" / "/"
			p.Choice(26, 27)
		case 26:
			p.TerminalChar('*')
		case 27:
			p.TerminalChar('/')
		case 28:
			// number / group
			p.Choice(29, 30)
		case 29:
			// number (from number / group)
			p.Alias(8)
		case 30:
			// group (from number / group)
			p.Alias(7)
		case 31:
			// "(" term ")"
			p.Sequence(32, 33)
		case 32:
			p.TerminalChar('(')
		case 33:
			// term ")"
			p.Sequence(34, 35)
		case 34:
			// term (from term ")")
			p.Alias(2)
		case 35:
			p.TerminalChar(')')
		case 36:
			// [0-9]+
			p.OneOrMore(37)
		case 37:
			p.TerminalRange('0', '9')
		default:
			return nil, fmt.Errorf("unknown code: %d", top.Code)
		}
	}
}
