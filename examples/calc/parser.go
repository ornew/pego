// Code generated by pego. DO NOT EDIT.

package calc

import (
	"fmt"

	"github.com/ornew/pego/pkg/cst"
	"github.com/ornew/pego/pkg/parser"
)

/*
expr <- additive
additive <- multiplicative (binary_op1 multiplicative)*
multiplicative <- value (binary_op2 value)*
binary_op1 <- "+" / "-"
binary_op2 <- "*" / "/"
value <- number / group
group <- "(" additive ")"
number <- [0-9]+
*/

var CodeNames = map[uint32]string{
	1: "expr",
	2: "additive",
	3: "multiplicative",
	4: "binary_op1",
	5: "binary_op2",
	6: "value",
	7: "group",
	8: "number",
}

func Demangle(code uint32) (string, bool) {
	name, ok := CodeNames[code]
	if !ok {
		return "", false
	}
	return name, true
}

func Parse(p *parser.Parser) (node *cst.Node, err error) {
	p.SetRuleCodeSize(8)
	for {
		top := p.Top()
		if top == nil {
			return p.Head(), nil
		}
		switch top.Code {
		case 1:
			// expr <- additive
			p.Alias(9)
		case 2:
			// additive <- multiplicative (binary_op1 multiplicative)*
			p.Alias(10)
		case 3:
			// multiplicative <- value (binary_op2 value)*
			p.Alias(16)
		case 4:
			// binary_op1 <- "+" / "-"
			p.Alias(22)
		case 5:
			// binary_op2 <- "*" / "/"
			p.Alias(25)
		case 6:
			// value <- number / group
			p.Alias(28)
		case 7:
			// group <- "(" additive ")"
			p.Alias(31)
		case 8:
			// number <- [0-9]+
			p.Alias(36)
		case 9:
			// additive (from additive)
			p.Alias(2)
		case 10:
			// multiplicative (binary_op1 multiplicative)*
			p.Sequence(11, 12)
		case 11:
			// multiplicative (from multiplicative (binary_op1 multiplicative)*)
			p.Alias(3)
		case 12:
			// (binary_op1 multiplicative)*
			p.ZeroOrMore(13)
		case 13:
			// binary_op1 multiplicative
			p.Sequence(14, 15)
		case 14:
			// binary_op1 (from binary_op1 multiplicative)
			p.Alias(4)
		case 15:
			// multiplicative (from binary_op1 multiplicative)
			p.Alias(3)
		case 16:
			// value (binary_op2 value)*
			p.Sequence(17, 18)
		case 17:
			// value (from value (binary_op2 value)*)
			p.Alias(6)
		case 18:
			// (binary_op2 value)*
			p.ZeroOrMore(19)
		case 19:
			// binary_op2 value
			p.Sequence(20, 21)
		case 20:
			// binary_op2 (from binary_op2 value)
			p.Alias(5)
		case 21:
			// value (from binary_op2 value)
			p.Alias(6)
		case 22:
			// "+" / "-"
			p.Choice(23, 24)
		case 23:
			p.TerminalChar('+')
		case 24:
			p.TerminalChar('-')
		case 25:
			// "*" / "/"
			p.Choice(26, 27)
		case 26:
			p.TerminalChar('*')
		case 27:
			p.TerminalChar('/')
		case 28:
			// number / group
			p.Choice(29, 30)
		case 29:
			// number (from number / group)
			p.Alias(8)
		case 30:
			// group (from number / group)
			p.Alias(7)
		case 31:
			// "(" additive ")"
			p.Sequence(32, 33)
		case 32:
			p.TerminalChar('(')
		case 33:
			// additive ")"
			p.Sequence(34, 35)
		case 34:
			// additive (from additive ")")
			p.Alias(2)
		case 35:
			p.TerminalChar(')')
		case 36:
			// [0-9]+
			p.OneOrMore(37)
		case 37:
			p.TerminalRange('0', '9')
		default:
			return nil, fmt.Errorf("unknown code: %d", top.Code)
		}
	}
}
